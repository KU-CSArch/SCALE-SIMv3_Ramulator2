# Config 설정값 상세 해석

## ReadRequestBuffer & WriteRequestBuffer

### 정의

```ini
ReadRequestBuffer: 512      ← DRAM 읽기 요청 큐 크기
WriteRequestBuffer: 512     ← DRAM 쓰기 요청 큐 크기
```

### 의미: "대기 줄의 크기"

```
DRAM 읽기 요청 큐:
┌─────────────────────────────────────┐
│ 읽기 요청 대기 줄 (최대 512개)      │
│                                      │
│ [요청1] [요청2] [요청3] ... [요청512]│
│   ↓
│ DRAM이 처리 중 (응답 대기 10-100사이클)
└─────────────────────────────────────┘

만약 요청이 512개를 초과하면?
→ "큐가 가득 찼다" 경고 발생
→ Prefetch 일시 중단 (메모리 과부하)
```

### 구체적 예시

```
시나리오: QKT 레이어 (M=1024, K=64, N=1024)

Prefetch 요청 패턴:
├─ Cycle 0: IFMAP 64KB prefetch 요청 (주소 0~16384)
├─ Cycle 10: IFMAP 64KB prefetch 요청
├─ Cycle 20: IFMAP 64KB prefetch 요청
├─ ...
└─ Cycle 1000: FILTER prefetch 요청들

각 prefetch 요청:
- DRAM에서 읽을 주소 리스트
- 응답 예상 사이클

ReadRequestBuffer 역할:
"이 512개 요청까지는 한번에 큐에 넣을 수 있어"

만약 512개 초과:
"어, 더 이상 넣을 수 없어, 기다려"
→ DRAM 응답 기다림 (기존 요청 처리 완료)
→ 그 다음에 새 요청 추가
```

---

## [layout] 섹션: SRAM 뱅크 구조

### IfmapSRAMBankNum: 10

```
IFMAP SRAM (6 MB)을 10개 뱅크로 분할:

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ Bank 0  │ Bank 1  │ Bank 2  │ Bank 3  │ Bank 4  │ Bank 5  │ Bank 6  │ Bank 7  │ Bank 8  │ Bank 9  │
├─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │ 600 KB  │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘

각 뱅크는 독립적으로 접근 가능 → 병렬 접근!
```

### IfmapSRAMBankPort: 2

```
각 뱅크가 2개 포트를 가짐:

┌──────────────────────────┐
│  Bank 0 (600 KB)         │
├──────────────────────────┤
│  Port 0: 읽기 전용       │ ← PE(0,0) 접근 가능
│  Port 1: 읽기 전용       │ ← PE(0,1) 접근 가능
│                          │
│ (동시에 2개 PE가 접근)    │
└──────────────────────────┘

결과: 한 사이클에 Bank 0에서 2개 주소 동시 읽기 가능
```

### IfmapSRAMBankBandwidth: 10

```
각 뱅크의 대역폭: 10 (단위: GB/s 또는 요소/사이클)

IFMAP SRAM 전체 대역폭:
= 뱅크 개수 × 뱅크당 대역폭
= 10 × 10
= 100 (전체)

PE 배열 접근 능력:
- 256 × 256 = 65,536 PE
- 모두 동시에 SRAM에 접근하려면?
  → 불가능 (충돌 발생)
  → 뱅크 구조로 분산

실제 접근:
PE(0,0) → Bank 0
PE(0,1) → Bank 1
PE(0,2) → Bank 2
PE(0,3) → Bank 3
PE(0,4) → Bank 4
PE(0,5) → Bank 5
PE(0,6) → Bank 6
PE(0,7) → Bank 7
PE(0,8) → Bank 8
PE(0,9) → Bank 9
PE(0,10) → Bank 0 (다시 순환)
PE(0,11) → Bank 1
...

→ 10개 PE가 각각 다른 뱅크 접근
→ 충돌 최소화!
```

### 메모리 뱅크 구조 다이어그램

```
IFMAP SRAM (6 MB):
                    Port 0  Port 1
                    (읽기) (읽기)
                      |      |
┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
│Bank0 │Bank1 │Bank2 │Bank3 │Bank4 │Bank5 │Bank6 │Bank7 │Bank8 │Bank9 │
├──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤
│ 각 뱅크: 2개 포트, 10 GB/s 대역폭                                     │
└──────────────────────────────────────────────────────────────────────┘
  ↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑
PE(0,0) PE(0,1) PE(0,2) ... 동시 접근 (충돌 없음!)
```

---

## [sparsity] 섹션: 희소성 (Sparsity) 설정

### SparsitySupport: false

```
희소성 지원 여부:

false = 희소성 미지원
├─ 모든 요소를 처리 (0과 1이 모두)
├─ 불필요한 0 곱셈도 수행
└─ 계산 낭비

true = 희소성 지원
├─ 0인 요소 스킵
├─ 1인 요소만 처리
└─ 성능 향상
```

### SparseRep: ellpack_block

```
희소 데이터 표현 방식 (희소성 활성화 시):

"ellpack_block" = Ellpack 형식으로 블록 단위 압축

예: 희소 가중치 행렬
┌                  ┐
│ 1  0  0  2       │
│ 0  3  0  0       │
│ 4  0  5  0       │
│ 0  0  0  6       │
└                  ┘

변환: ellpack_block 형식
┌         ┐
│ 1 2     │  ← 각 행에서 0이 아닌 요소만
│ 3       │
│ 4 5     │
│ 6       │
└         ┐

저장 방식:
- 0이 아닌 값들만 저장
- 메모리 효율 ↑
- 연산 시간 ↓
```

### OptimizedMapping: false

```
최적화된 희소성 매핑 사용 여부:

false = 기본 희소성 처리
├─ N:M sparsity pattern 적용 (균일한 0 위치)
├─ 예측 가능한 구조
└─ 더 간단함

true = 동적 최적화
├─ 임의의 0 위치 처리 (완전 불규칙)
├─ Ramulator와 연동 가능
└─ 더 복잡함
```

### BlockSize: 8

```
희소성 블록 크기:

BlockSize = 8
→ 8×8 블록 단위로 희소성 처리

예: 필터를 8×8 블록으로 분할
┌─────────────────┐
│ [8×8] [8×8]     │
│ [8×8] [8×8]     │
│ [8×8] [8×8]     │
│ [8×8] [8×8]     │
└─────────────────┘

각 블록이 희소한지 판단 후 스킵
```

### RandomNumberGeneratorSeed: 40

```
난수 생성 시드:

희소성이 임의로 설정될 때 사용
├─ 같은 시드 → 같은 결과 (재현 가능)
├─ 다른 시드 → 다른 희소성 패턴
└─ 일관된 실험을 위해 고정값 사용
```

---

## [run_presets] 섹션: 실행 설정

### InterfaceBandwidth: USER

```
메모리 대역폭 설정 방식:

USER = 사용자 입력값 사용
├─ config의 Bandwidth 값 사용
├─ 이 경우: 10 GB/s
└─ 직접 지정

다른 옵션들:
- AUTO: 자동 계산 (아키텍처 기반)
- RAMULATOR: Ramulator 시뮬레이션 결과 사용
```

### UseRamulatorTrace: False

```
Ramulator 시뮬레이터 사용 여부:

false = 사용 안함
├─ SCALE-Sim 자체 메모리 시뮬레이션만 사용
├─ DRAM 타이밍 간단하게 모델링
└─ 빠른 시뮬레이션

true = 사용함
├─ Ramulator와 연동 (DRAM 정확한 시뮬레이션)
├─ IFMAP_DRAM_TRACE.csv를 Ramulator에 입력
├─ DRAM 성능 정확한 분석
└─ 느린 시뮬레이션
```

---

## 전체 설정 요약

### 버퍼 설정 (Prefetch 관리)

```
ReadRequestBuffer: 512
└─ 동시에 최대 512개 DRAM 읽기 요청 대기 가능

WriteRequestBuffer: 512
└─ 동시에 최대 512개 DRAM 쓰기 요청 대기 가능

→ 메모리 대역폭 과부하 방지
```

### 메모리 뱅크 설정 (병렬 접근)

```
IFMAP SRAM:
  10개 뱅크 × 600KB/뱅크 = 6 MB
  각 뱅크 2개 포트 (동시 2개 주소 접근)
  대역폭 10 GB/s × 10 뱅크 = 100 GB/s (이론치)

FILTER SRAM:
  동일 구조 (10개 뱅크, 2개 포트)

→ PE 배열 65,536개가 동시 접근 시
  뱅크로 분산해서 충돌 최소화
```

### 희소성 설정 (계산 최적화)

```
SparsitySupport: false
└─ 이 config에서는 희소성 미사용 (모든 요소 처리)

BlockSize: 8
└─ 만약 희소성 사용하면 8×8 블록 단위 처리
```

### 실행 설정 (시뮬레이션 방식)

```
InterfaceBandwidth: USER (10 GB/s)
UseRamulatorTrace: false
└─ SCALE-Sim 자체 시뮬레이션만 사용
└─ Ramulator 연동 안함 (더 빠름)
```

---

## 이 설정의 의미

### GoogleTPU v1 (이 설정)의 특징

```
┌─────────────────────────────────────────────┐
│   고대역폭 메모리 뱅크 구조 (10개)          │
│   → PE 배열의 병렬 접근 지원                │
│                                              │
│   완벽한 Prefetch 버퍼 (512개 동시 요청)   │
│   → DRAM 레이턴시 효과적으로 숨김           │
│                                              │
│   희소성 미지원 (false)                     │
│   → Dense 연산 (모든 요소 처리)             │
│                                              │
│   Ramulator 미사용 (빠른 시뮬레이션)       │
│   → 대략적 성능 분석용                     │
└─────────────────────────────────────────────┘
```

### 성능의 핵심

```
PE 배열: 65,536 개 (매우 많음)
├─ Peak Performance: 65,536 MACs/cycle

SRAM 대역폭: 100 GB/s (이론치)
├─ 병렬 뱅크로 충분한가?

DRAM 대역폭: 10 GB/s (현실적)
├─ 메모리 병목의 주범 ← 실제 측정 필요!

→ 이 설정으로 시뮬레이션하면
  "DRAM 대역폭이 얼마나 병목인가"를 알 수 있음
```
