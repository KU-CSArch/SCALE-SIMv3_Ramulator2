# Operand Matrix 상세 설명 (초보자용)

## 핵심 개념: "메모리 어디에서 읽을 데이터를 꺼낼까?"

Operand Matrix는 **Systolic Array(PE 배열)가 메모리의 어느 주소에서 데이터를 읽어야 하는지 알려주는 지도(Map)**입니다.

---

## 1단계: 문제 상황

### GEMM 연산: C = A × B

```
A (입력 행렬):     B (가중치 행렬):    C (출력 행렬):
M=4행, K=3열        K=3행, N=2열        M=4행, N=2열

예:                예:                결과:
┌     ┐            ┌   ┐              ┌    ┐
│ 1 2 3 │          │1 2│              │? ?│
│ 4 5 6 │  ×       │3 4│  =           │? ?│
│ 7 8 9 │          │5 6│              │? ?│
│10 11 12│         └   ┘              │? ?│
└     ┘                               └    ┘

연산량: M × N × K = 4 × 2 × 3 = 24 MAC 연산
```

### 문제: PE 배열이 "어디서 데이터를 가져올까?"

```
PE 배열 (256×256개의 작은 계산기):

PE(0,0): A[0,?]과 B[?,0]을 곱해서 C[0,0]을 계산
PE(0,1): A[0,?]과 B[?,1]을 곱해서 C[0,1]을 계산
PE(1,0): A[1,?]과 B[?,0]을 곱해서 C[1,0]을 계산
...

→ 각 PE가 **메모리 어디에서** 데이터를 읽을지 명확해야 함!
```

---

## 2단계: 메모리 주소 지정

### 메모리 구조: 3개 영역으로 분리

```
메인 메모리 (일렬로 배열된 주소)

┌─────────────────────────────────────────┐
│         IFMAP 영역                      │
│    (A 행렬이 저장되는 곳)               │
│                                         │
│ 주소 0: A[0,0]=1                        │
│ 주소 1: A[0,1]=2                        │
│ 주소 2: A[0,2]=3                        │
│ 주소 3: A[1,0]=4                        │
│ 주소 4: A[1,1]=5                        │
│ 주소 5: A[1,2]=6                        │
│ ...                                     │
│ 주소 11: A[3,2]=12                      │
└─────────────────────────────────────────┘
         주소 0 ~ 11
         
┌─────────────────────────────────────────┐
│         FILTER 영역                     │
│    (B 행렬이 저장되는 곳)               │
│                                         │
│ 주소 10000000: B[0,0]=1                 │
│ 주소 10000001: B[0,1]=2                 │
│ 주소 10000002: B[1,0]=3                 │
│ 주소 10000003: B[1,1]=4                 │
│ 주소 10000004: B[2,0]=5                 │
│ 주소 10000005: B[2,1]=6                 │
└─────────────────────────────────────────┘
      주소 10000000 ~ 10000005
      
┌─────────────────────────────────────────┐
│         OFMAP 영역                      │
│    (C 행렬이 저장되는 곳)               │
│                                         │
│ 주소 20000000: C[0,0] (결과)             │
│ 주소 20000001: C[0,1] (결과)             │
│ 주소 20000002: C[1,0] (결과)             │
│ ...                                     │
│ 주소 20000007: C[3,1] (결과)             │
└─────────────────────────────────────────┘
      주소 20000000 ~ 20000007
```

---

## 3단계: IFMAP 주소 행렬 만들기

### 목표: "각 출력 픽셀마다 어떤 입력을 읽을까?"

#### 간단한 버전: 메모리에 저장된 A(IFMAP)

```
2D 배열 A:          1D 메모리:
┌       ┐           
│ 1 2 3 │  →  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
│ 4 5 6 │           ↑     ↑     ↑     ↑
│ 7 8 9 │        주소0  주소1  주소2  주소3  ...
│10 11 12│
└       ┘

변환 규칙:
A[행, 열] → 메모리 주소 = 행 × 열폭 + 열
A[0, 0] → 주소 0 × 3 + 0 = 0
A[0, 1] → 주소 0 × 3 + 1 = 1
A[0, 2] → 주소 0 × 3 + 2 = 2
A[1, 0] → 주소 1 × 3 + 0 = 3
A[1, 1] → 주소 1 × 3 + 1 = 4
A[1, 2] → 주소 1 × 3 + 2 = 5
...
```

#### 계산: 각 출력 픽셀은 어떤 입력들이 필요한가?

```
GEMM: C[i, j] = Σ(k=0 to K-1) A[i, k] × B[k, j]

예를 들어:
C[0, 0] = A[0,0]×B[0,0] + A[0,1]×B[1,0] + A[0,2]×B[2,0]
        = 1×1 + 2×3 + 3×5 = 1+6+15 = 22

따라서 C[0,0]을 계산하려면:
→ A[0, 0], A[0, 1], A[0, 2]를 읽어야 함
→ 메모리 주소: 0, 1, 2
```

#### IFMAP 주소 행렬 생성

```python
# 2D 배열로 표현
IFMAP_addr_matrix = [
    [0,    1,    2   ],  # C[0,?]을 계산하려면 A[0,:] 필요
    [3,    4,    5   ],  # C[1,?]을 계산하려면 A[1,:] 필요
    [6,    7,    8   ],  # C[2,?]을 계산하려면 A[2,:] 필요
    [9,    10,   11  ],  # C[3,?]을 계산하려면 A[3,:] 필요
]

크기: (4, 3) = (M, K) = (출력행수, 입력열수)

각 행: 해당 출력 픽셀을 계산하는 데 필요한 입력 메모리 주소들
```

#### 계산식

```python
def calc_ifmap_addr(pixel_idx, filter_pos):
    """
    pixel_idx: 출력 픽셀 인덱스 (0~3, 즉 0~M-1)
    filter_pos: 필터 창 위치 (0~2, 즉 0~K-1)
    """
    # GEMM에서는 stride=1, padding=0이므로 간단함
    ifmap_row = pixel_idx        # 픽셀 인덱스 = 입력 행 인덱스
    ifmap_col = filter_pos       # 필터 위치 = 입력 열 인덱스
    
    # 1D 주소 계산
    address = ifmap_row * K + ifmap_col + IFMAP_OFFSET
    #         = pixel_idx * 3 + filter_pos + 0
    
    return address

# 예시 계산
calc_ifmap_addr(0, 0) = 0 * 3 + 0 + 0 = 0  ✓
calc_ifmap_addr(0, 1) = 0 * 3 + 1 + 0 = 1  ✓
calc_ifmap_addr(0, 2) = 0 * 3 + 2 + 0 = 2  ✓
calc_ifmap_addr(1, 0) = 1 * 3 + 0 + 0 = 3  ✓
calc_ifmap_addr(3, 2) = 3 * 3 + 2 + 0 = 11 ✓
```

---

## 4단계: FILTER 주소 행렬 만들기

### 목표: "각 필터는 메모리 어디에 있을까?"

#### FILTER 메모리 레이아웃

```
B 행렬:             메모리:
┌   ┐               
│1 2│           주소 10000000: 1
│3 4│           주소 10000001: 2
│5 6│           주소 10000002: 3
└   ┘           주소 10000003: 4
                주소 10000004: 5
                주소 10000005: 6

변환:
B[행, 열] → 주소 = 10000000 + 행 × N + 열
B[0, 0] → 10000000 + 0×2 + 0 = 10000000
B[0, 1] → 10000000 + 0×2 + 1 = 10000001
B[1, 0] → 10000000 + 1×2 + 0 = 10000002
...
```

#### FILTER 주소 행렬 생성

```python
FILTER_addr_matrix = [
    [10000000, 10000001],  # B[0,:] 가중치들
    [10000002, 10000003],  # B[1,:] 가중치들
    [10000004, 10000005],  # B[2,:] 가중치들
]

크기: (3, 2) = (K, N) = (입력열수, 출력열수)

각 행: 각 필터 위치의 가중치들이 저장된 메모리 주소
```

#### 계산식

```python
def calc_filter_addr(filter_pos, filter_idx):
    """
    filter_pos: 필터 위치 (0~2, 즉 0~K-1)
    filter_idx: 필터 인덱스 (0~1, 즉 0~N-1)
    """
    address = FILTER_OFFSET + filter_pos * N + filter_idx
    #       = 10000000 + filter_pos * 2 + filter_idx
    
    return address

# 예시
calc_filter_addr(0, 0) = 10000000 + 0*2 + 0 = 10000000 ✓
calc_filter_addr(0, 1) = 10000000 + 0*2 + 1 = 10000001 ✓
calc_filter_addr(1, 0) = 10000000 + 1*2 + 0 = 10000002 ✓
calc_filter_addr(2, 1) = 10000000 + 2*2 + 1 = 10000005 ✓
```

---

## 5단계: OFMAP 주소 행렬 만들기

### 목표: "각 출력은 메모리 어디에 저장될까?"

#### OFMAP 메모리 레이아웃

```
C 행렬:             메모리:
┌  ┐               
│? ?│           주소 20000000: C[0,0]
│? ?│           주소 20000001: C[0,1]
│? ?│           주소 20000002: C[1,0]
│? ?│           주소 20000003: C[1,1]
└  ┘            주소 20000004: C[2,0]
                주소 20000005: C[2,1]
                주소 20000006: C[3,0]
                주소 20000007: C[3,1]

변환:
C[행, 열] → 주소 = 20000000 + 행 × N + 열
C[0, 0] → 20000000 + 0×2 + 0 = 20000000
C[0, 1] → 20000000 + 0×2 + 1 = 20000001
...
```

#### OFMAP 주소 행렬 생성

```python
OFMAP_addr_matrix = [
    [20000000, 20000001],  # C[0,:] 출력들
    [20000002, 20000003],  # C[1,:] 출력들
    [20000004, 20000005],  # C[2,:] 출력들
    [20000006, 20000007],  # C[3,:] 출력들
]

크기: (4, 2) = (M, N) = (출력행수, 출력열수)

각 행: 해당 출력 픽셀들이 저장될 메모리 주소
```

#### 계산식

```python
def calc_ofmap_addr(pixel_idx, filter_idx):
    """
    pixel_idx: 출력 픽셀 인덱스 (0~3, 즉 0~M-1)
    filter_idx: 필터 인덱스 (0~1, 즉 0~N-1)
    """
    address = OFMAP_OFFSET + pixel_idx * N + filter_idx
    #       = 20000000 + pixel_idx * 2 + filter_idx
    
    return address

# 예시
calc_ofmap_addr(0, 0) = 20000000 + 0*2 + 0 = 20000000 ✓
calc_ofmap_addr(0, 1) = 20000000 + 0*2 + 1 = 20000001 ✓
calc_ofmap_addr(3, 1) = 20000000 + 3*2 + 1 = 20000007 ✓
```

---

## 6단계: Systolic Array가 이 정보를 어떻게 사용할까?

### 한 가지 연산 예시: C[0,0] 계산

```
GEMM: C[0, 0] = A[0,0]×B[0,0] + A[0,1]×B[1,0] + A[0,2]×B[2,0]
                = 1×1 + 2×3 + 3×5
                = 1 + 6 + 15
                = 22

Systolic Array의 수행 과정:

Step 1: 첫 번째 항 (A[0,0] × B[0,0])
  IFMAP 주소 읽기:   IFMAP_addr_matrix[0, 0] = 0
  메모리에서 값 읽기: mem[0] = A[0,0] = 1
  
  FILTER 주소 읽기:  FILTER_addr_matrix[0, 0] = 10000000
  메모리에서 값 읽기: mem[10000000] = B[0,0] = 1
  
  곱하기: 1 × 1 = 1
  OFMAP에 누적: acc = 0 + 1 = 1

Step 2: 두 번째 항 (A[0,1] × B[1,0])
  IFMAP 주소: IFMAP_addr_matrix[0, 1] = 1 → mem[1] = 2
  FILTER 주소: FILTER_addr_matrix[1, 0] = 10000002 → mem[10000002] = 3
  곱하기: 2 × 3 = 6
  누적: acc = 1 + 6 = 7

Step 3: 세 번째 항 (A[0,2] × B[2,0])
  IFMAP 주소: IFMAP_addr_matrix[0, 2] = 2 → mem[2] = 3
  FILTER 주소: FILTER_addr_matrix[2, 0] = 10000004 → mem[10000004] = 5
  곱하기: 3 × 5 = 15
  누적: acc = 7 + 15 = 22

최종 결과 저장:
  OFMAP 주소: OFMAP_addr_matrix[0, 0] = 20000000
  메모리에 쓰기: mem[20000000] = 22
```

### PE 배열이 병렬로 수행하는 과정

```
PE(0,0)은 C[0,0] 계산        PE(0,1)은 C[0,1] 계산
PE(1,0)은 C[1,0] 계산        PE(1,1)은 C[1,1] 계산
PE(2,0)은 C[2,0] 계산        PE(2,1)은 C[2,1] 계산
PE(3,0)은 C[3,0] 계산        PE(3,1)은 C[3,1] 계산

모두 **동시에** 수행!

PE(i, j)가 수행하는 작업:
for k in range(K):  # K=3
  ifmap_val = mem[IFMAP_addr_matrix[i, k]]
  filter_val = mem[FILTER_addr_matrix[k, j]]
  result += ifmap_val × filter_val
  
mem[OFMAP_addr_matrix[i, j]] = result
```

---

## 7단계: 정리 - 왜 Operand Matrix가 필요한가?

### 문제: 메모리 주소는 2D, 하지만 메모리는 1D

```
우리가 생각하는 방식:
C[행, 열] = Σ A[행, k] × B[k, 열]
                ↑ 2D 인덱스

메모리 구조:
메모리는 일렬로 배열되어 있음
[값0, 값1, 값2, 값3, ...]
 ↑ 1D 주소

→ 2D 인덱스를 1D 주소로 변환해야 함!
```

### Operand Matrix가 하는 일

```
IFMAP_addr_matrix[pixel_idx, filter_pos] = 실제 메모리 주소
FILTER_addr_matrix[filter_pos, filter_idx] = 실제 메모리 주소
OFMAP_addr_matrix[pixel_idx, filter_idx] = 실제 메모리 주소

PE 배열은 이 행렬들을 보고:
"아, C[i,j]를 계산하려면..."
→ 메모리 주소 X에서 입력을 읽고
→ 메모리 주소 Y에서 가중치를 읽고
→ 계산 후 메모리 주소 Z에 저장하면 되겠구나!

→ 메모리 접근이 정확해짐!
→ 성능 시뮬레이션이 정확해짐!
```

---

## 8단계: 실제 숫자로 보는 예시 (QKT, M=4, K=3, N=2)

### 메모리 상태

```
[IFMAP 영역]
메모리:   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11
값:       1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12

[FILTER 영역]
메모리:  10M, 10M+1, 10M+2, 10M+3, 10M+4, 10M+5
값:        1,     2,      3,      4,      5,      6
         (B[0,0])(B[0,1])(B[1,0])(B[1,1])(B[2,0])(B[2,1])

[OFMAP 영역]
메모리:  20M, 20M+1, 20M+2, 20M+3, 20M+4, 20M+5, 20M+6, 20M+7
초기값:    0,     0,      0,      0,      0,      0,      0,      0
(M은 1,000,000을 의미)
```

### Operand Matrix

```
IFMAP_addr_matrix:
  pixel_idx=0: [0,     1,     2]     ← A[0,:]에 접근
  pixel_idx=1: [3,     4,     5]     ← A[1,:]에 접근
  pixel_idx=2: [6,     7,     8]     ← A[2,:]에 접근
  pixel_idx=3: [9,     10,    11]    ← A[3,:]에 접근

FILTER_addr_matrix:
  filter_pos=0: [10M,  10M+1]        ← B[0,:]에 접근
  filter_pos=1: [10M+2, 10M+3]       ← B[1,:]에 접근
  filter_pos=2: [10M+4, 10M+5]       ← B[2,:]에 접근

OFMAP_addr_matrix:
  pixel_idx=0: [20M,  20M+1]         ← C[0,:]에 저장
  pixel_idx=1: [20M+2, 20M+3]        ← C[1,:]에 저장
  pixel_idx=2: [20M+4, 20M+5]        ← C[2,:]에 저장
  pixel_idx=3: [20M+6, 20M+7]        ← C[3,:]에 저장
```

### 계산 흐름 (PE(0,0) - C[0,0] 계산)

```
초기: acc = 0

루프 k=0:
  IFMAP[0,0] 주소 = IFMAP_addr[0,0] = 0
  A값 = mem[0] = 1
  
  FILTER[0,0] 주소 = FILTER_addr[0,0] = 10M
  B값 = mem[10M] = 1
  
  MAC: 1 × 1 = 1
  누적: acc = 0 + 1 = 1

루프 k=1:
  IFMAP[0,1] 주소 = IFMAP_addr[0,1] = 1
  A값 = mem[1] = 2
  
  FILTER[1,0] 주소 = FILTER_addr[1,0] = 10M+2
  B값 = mem[10M+2] = 3
  
  MAC: 2 × 3 = 6
  누적: acc = 1 + 6 = 7

루프 k=2:
  IFMAP[0,2] 주소 = IFMAP_addr[0,2] = 2
  A값 = mem[2] = 3
  
  FILTER[2,0] 주소 = FILTER_addr[2,0] = 10M+4
  B값 = mem[10M+4] = 5
  
  MAC: 3 × 5 = 15
  누적: acc = 7 + 15 = 22

최종 저장:
  OFMAP[0,0] 주소 = OFMAP_addr[0,0] = 20M
  mem[20M] = 22  ✓

→ C[0,0] = 22 (계산 완료!)
```

---

## 최종 정리

### Operand Matrix의 역할

1. **2D 배열 인덱스 → 1D 메모리 주소 변환**
   ```
   C[i, j] (2D) → OFMAP_addr_matrix[i, j] (1D 메모리 주소)
   ```

2. **메모리 접근 규칙을 미리 결정**
   ```
   "PE(i,j)는 이 사이클에 이 주소들에서 읽고 쓴다"
   ```

3. **메모리 대역폭 분석 가능**
   ```
   "메모리 주소들이 이 패턴으로 접근되니까
    대역폭 병목은 여기겠네!"
   ```

4. **TRACE 파일 생성의 기초**
   ```
   Operand Matrix의 주소 패턴
   → Systolic Array의 접근 패턴 (Trace)
   → IFMAP_SRAM_TRACE, IFMAP_DRAM_TRACE 생성
   ```

### 한 줄 요약

**Operand Matrix = "이 연산에서 메모리를 어떻게 접근할지 미리 계산해서 저장한 표"**
